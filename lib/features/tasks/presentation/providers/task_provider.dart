import 'package:flutter_riverpod/flutter_riverpod.dart';
import '../../data/datasources/task_remote_data_source.dart';
import '../../data/repositories/task_repository_impl.dart';
import '../../domain/entities/task.dart';
import '../../domain/repositories/task_repository.dart';
import '../../domain/usecases/create_task.dart';
import '../../domain/usecases/delete_task.dart';
import '../../domain/usecases/get_tasks.dart';
import '../../domain/usecases/update_task.dart';
import '../../../../core/services/notification_service.dart';

// --- Data Layer Providers ---

final taskRemoteDataSourceProvider = Provider<TaskRemoteDataSource>((ref) {
  // In a real app, this would be a singleton or scoped properly
  return MockTaskRemoteDataSource();
});

final taskRepositoryProvider = Provider<TaskRepository>((ref) {
  return TaskRepositoryImpl(ref.watch(taskRemoteDataSourceProvider));
});

// --- Domain Layer Providers ---

final getTasksUseCaseProvider = Provider<GetTasks>((ref) {
  return GetTasks(ref.watch(taskRepositoryProvider));
});

final createTaskUseCaseProvider = Provider<CreateTask>((ref) {
  return CreateTask(ref.watch(taskRepositoryProvider));
});

final updateTaskUseCaseProvider = Provider<UpdateTask>((ref) {
  return UpdateTask(ref.watch(taskRepositoryProvider));
});

final deleteTaskUseCaseProvider = Provider<DeleteTask>((ref) {
  return DeleteTask(ref.watch(taskRepositoryProvider));
});

// --- Presentation Layer (State) ---

final taskBoardProvider = AsyncNotifierProvider.family<TaskBoardNotifier, List<Task>, String>(() {
  return TaskBoardNotifier();
});

class TaskBoardNotifier extends FamilyAsyncNotifier<List<Task>, String> {
  late String _projectId;

  @override
  Future<List<Task>> build(String arg) async {
    _projectId = arg;
    return _fetchTasks();
  }

  Future<List<Task>> _fetchTasks() async {
    final getTasks = ref.read(getTasksUseCaseProvider);
    final result = await getTasks(_projectId);
    return result.fold(
      (failure) {
        throw failure;
      },
      (tasks) => tasks,
    );
  }

  Future<void> addTask(String title, String description, DateTime dueDate, TaskPriority priority) async {
    final createTask = ref.read(createTaskUseCaseProvider);
    final newTask = Task(
      id: '', // ID is generated by DataSource
      projectId: _projectId,
      title: title,
      description: description,
      dueDate: dueDate,
      priority: priority,
      status: TaskStatus.todo,
    );

    // Optimistic Update
    state = const AsyncValue.loading();
    final result = await createTask(newTask);

    result.fold(
      (failure) => state = AsyncValue.error(failure.message, StackTrace.current),
      (createdTask) {
        ref.invalidateSelf();
      },
    );
  }

  Future<void> updateTask(Task task) async {
     // Optimistic Update
    final previousState = state.value;
    if (previousState != null) {
      final updatedList = previousState.map((t) => t.id == task.id ? task : t).toList();
      state = AsyncValue.data(updatedList);

      final updateTaskUseCase = ref.read(updateTaskUseCaseProvider);
      final result = await updateTaskUseCase(task);

      result.fold(
        (failure) {
          // Revert on failure
          state = AsyncValue.data(previousState);
          state = AsyncValue.error(failure.message, StackTrace.current);
        },
        (_) {},
      );
    }
  }

  Future<void> updateTaskStatus(Task task, TaskStatus newStatus) async {
    // Optimistic Update
    final previousState = state.value;
    if (previousState != null) {
      final updatedTask = task.copyWith(status: newStatus);
      final updatedList = previousState.map((t) => t.id == task.id ? updatedTask : t).toList();
      state = AsyncValue.data(updatedList);

      final updateTask = ref.read(updateTaskUseCaseProvider);
      final result = await updateTask(updatedTask);

      result.fold(
        (failure) {
          // Revert on failure
          state = AsyncValue.data(previousState);
          state = AsyncValue.error(failure.message, StackTrace.current);
        },
        (_) {
          // Success
          if (newStatus == TaskStatus.done && task.status != TaskStatus.done) {
             ref.read(notificationServiceProvider).showNotification(
               id: task.id.hashCode,
               title: 'Task Completed!',
               body: 'You have completed "${task.title}". Great job!',
             );
          }
        },
      );
    }
  }

  Future<void> deleteTask(String taskId) async {
      // Optimistic Update
      final previousState = state.value;
      if (previousState != null) {
          final updatedList = previousState.where((t) => t.id != taskId).toList();
          state = AsyncValue.data(updatedList);

          final deleteTask = ref.read(deleteTaskUseCaseProvider);
          final result = await deleteTask(taskId);

          result.fold(
              (failure) {
                  // Revert
                  state = AsyncValue.data(previousState);
                  state = AsyncValue.error(failure.message, StackTrace.current);
              },
              (_) {},
          );
      }
  }
}
